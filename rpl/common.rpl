---- -*- Mode: rpl; -*-                                                                             
---- vim:syn=rosie
----
---- common.rpl   Common patterns in Rosie Pattern Language
----
---- Â© Copyright IBM Corporation 2016, 2017.
---- LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)
---- AUTHOR: Jamie A. Jennings

rpl 1.0

alias any = .
alias whitespace = [:space:]
alias digit = [:digit:]
alias letter = [:alpha:]

-- [:graph:] won't match unicode, but these will:
alias common.graph = {![:space:] .}
alias common.id_char = [_-] / {![:space:] ![:punct:] .}
-- test common.id_char accepts "_", "-", "i", "3"
-- test common.id_char rejects "#", "%", "`"

alias hex_only = { [a-f] / [A-F] }
alias hex_digits = { digit / [a-f] / [A-F] }
--alias common.hex = { digit hex_digits+ } / { hex_only+ digit hex_digits* }
common.int = { [+-]? digit+ !hex_only}	     -- at least one digit, and not a hex number
-- test common.int accepts "34", "+34", "-34"
-- test common.int rejects "BEEF", "0x20"
common.frac = { [.] [0-9]+ }
-- test common.frac accepts ".0", ".01", ".3210009831", ".1"
-- test common.exp rejects "0.", "1.1", "-.1"
common.mantissa = { [+-]? digit+ "." digit+ }  -- float with digits on either side of radix
-- test common.mantissa accepts "1.23", "+1.23", "-1.23"
-- test common.mantissa rejects "12", "bob", "1."
common.exp = { [eE] common.int }
-- test common.exp accepts "e0", "e01", "e321", "e+10", "e-99", "E101", "E+1", "E+02"
-- test common.exp rejects "e0.", "e0a", "e+-10", "Ef"
common.float = { common.mantissa common.exp? } 
-- test common.float accepts "6.02e23", "3.00E08", "0.123", "-2.0", "-2.0e1", "0.456e-101"
-- test common.float rejects "6.02F23", "3.00E--08", "123"
-- test common.float accepts "-1.32", "6.02E23", "+0.314e1"
-- test common.float rejects "0x01", "--2", "a", "-1", "+0"
common.hex = hex_digits+ 		     --  use with care! will match words and decimal numbers
-- test common.hex accepts "BEEF", "f4c3b00c"
-- test common.hex rejects "0xBEEF", "Facebook"
common.denoted_hex = { "0x" common.hex }
-- test common.denoted_hex accepts "0xBEEF", "0x20"
-- test common.denoted_hex rejects "BEEF", "0x2o"

-- N.B. signed_number matches the JSON spec for numbers
alias common.signed_number = (common.float / common.int)
common.number =  (common.denoted_hex /  common.float / common.int / common.hex)
-- test common.number accepts "0", "01", "-1", "-1.0", "+1", "+0", "+0.0", "-0.3e+1", "+1.1E-1", "0x1a", "face"
common.word = letter+
-- test common.word accepts "foo"
-- test common.word rejects "12356", "  ", "#!", "ac475"

-- This definition is essentially what grok uses, which isn't great:
-- common.unix_path = { "/" ([:alnum:]/[_%!$@:.,~-])+ / ".." / "." }+

alias common.unix_path = { {".." / "."}? {"/" {[:alnum:]/[_%!$@:.,~-]}+ }+  }
--alias common.pathchar = [[:alnum:][_%!$@:.,~-]]
--alias common.unix_path = { {"../" / "./" / "/"}? {pathchar+ {"/" pathchar+}+ } }
alias common.windows_path = { {[:alpha:]+ ":"}? {"\\" {![\\?*] any}* }+ }
common.path = common.unix_path / common.windows_path

alias dash_under = [-_]

alias identifier_char = { letter / digit / "_" }
alias identifier_plus_char = { letter / digit / dash_under / "$" }

common.identifier = {letter identifier_char*}
common.identifier_plus = {letter identifier_plus_char*}

alias identifier_plus_plus1 = { { {letter / dash_under / "$"} identifier_plus_char*} }
alias identifier_plus_plus2 = {digit+ identifier_plus_char*} -- FIXME: I match integers!
common.identifier_plus_plus = identifier_plus_plus1 / identifier_plus_plus2

common.dotted_identifier = { common.identifier_plus_plus { "." common.identifier_plus_plus}+ }

-- starts with a letter and contains a digit, or starts with a letter
--and contains a dash/under (otherwise, all the identifier_plus
--characters are allowed) 
common.identifier_not_word = { {letter {letter / dash_under}* [:digit:] identifier_plus_char*}
                               / {letter {letter / digit}* dash_under identifier_plus_char*} }

-- Upper case words which may also contain digits, dashes,
-- underlines. Note that we explicitly fail if the first upper case
-- letter is followed by a lower case one, since most sentences and
-- proper names start that way.
common.maybe_identifier = { [:upper:] ![:lower:] {[:upper:] / [:digit:] / dash_under}* }

alias h = [:xdigit:]
alias common.type4_guid_nocap = {h{8,8} "-" {h{4,4} "-"}{3,3} h{12,12}}
common.type4_guid = common.type4_guid_nocap

-- Quoted strings, using single or double quote
--
-- An escaped_string is a json string, in which double quotes must be escaped.
--
common.escaped_string = ["] { {[\\].} / [^"\\] }* ["]   -- "
-- test common.escaped_string accepts "\"\"", "\"foo\"", "\"I said, \\\"Hi\\\"\""
-- test common.escaped_string rejects "", "\"foo", "\"I said, \"Hi\""

-- Within a dquoted_string, the quote character can be escaped using a slash, OR by repeating it
-- twice, e.g. "".
alias common.dquoted_string = "\""  {"\\\"" / {! [\"] .}}* "\""

alias dquote = "\""			      -- "
alias escaped_dquote = "\\\"" / "\\\"\\\"" / "\"\"" -- \" or \"\" or "" 
alias squote = "'"			      -- '
alias escaped_squote = "\\'" / "\\'\\'" / "''"      -- \' or \'\' or ''
-- Capture the contents of a quoted field by assigning it to an RPL name:
double_quoted_field = {escaped_dquote / {!dquote .}}*
single_quoted_field = {escaped_squote / {!squote .}}*

-- Wrap the field contents with quotation marks:
alias common.dq = {dquote double_quoted_field dquote}
alias common.sq = {squote single_quoted_field squote}

-- Look for either double or single quoted fields
common.quoted_field = common.dq / common.sq

