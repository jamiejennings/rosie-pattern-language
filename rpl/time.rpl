---- -*- Mode: rpl; -*-                                                                             
---- vim:syn=rosie
----
---- time.rpl    Common time patterns in Rosie Pattern Language
----
---- Â© Copyright IBM Corporation 2016, 2017.
---- LICENSE: MIT License (https://opensource.org/licenses/mit-license.html)
---- AUTHORS: Jamie A. Jennings, Kevin Zander

--
-- RFC3339
--

--   date-fullyear   = 4DIGIT
--   date-month      = 2DIGIT  ; 01-12
--   date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
--                             ; month/year
--   time-hour       = 2DIGIT  ; 00-23
--   time-minute     = 2DIGIT  ; 00-59
--   time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
--                             ; rules
--   time-secfrac    = "." 1*DIGIT
--   time-numoffset  = ("+" / "-") time-hour ":" time-minute
--   time-offset     = "Z" / time-numoffset
--
--   partial-time    = time-hour ":" time-minute ":" time-second
--                     [time-secfrac]
--   full-date       = date-fullyear "-" date-month "-" date-mday
--   full-time       = partial-time time-offset
--
--   date-time       = full-date "T" full-time
--
-- Notes:
-- T and Z may be lowercase.
-- The "T" separator in the date-time rule can be a space instead.

--import core (for digit)
-- local until import
alias time.d = [:digit:]

-- RFC3339 patterns
time.hour = { { [01] [0-9] } /
              { "2"  [0-3] } }
-- test time.hour accepts "00", "15", "20", "23"
-- test time.hour rejects "", "0", "5", "24", "99"
time.minute = { [0-5] [0-9] }
-- test time.minute accepts "00", "25", "39", "59"
-- test time.minute rejects "", "0", "60", "99"
time.second = { { [0-5] [0-9] } /
                "60"            }     -- time_second must match 60 for leap second
-- test time.second accepts "00", "24", "47", "59", "60"
-- test time.second rejects "", "0", "9", "61", "99"
time.secfrac = { "." time.d+ }
-- test time.secfrac accepts ".00000", ".12435", ".99999999", ".0"
-- test time.secfrac rejects "", "0", ".", ".now", ".0r", ".never"
time.numoffset = { [+-] time.hour ":" time.minute }
-- test time.numoffset accepts "+00:10", "-23:59"
-- test time.numoffset rejects "@12:34", "-55:00", "+2:30"
time.offset = { [Zz] / time.numoffset }
-- test time.offset accepts "Z", "z", "+00:10", "-23:59"
-- test time.offset rejects "", "2", "*00:00", "+00:60"
time.partial = { time.hour ":" time.minute ":" time.second time.secfrac? }
-- test time.partial accepts "00:00:00", "00:00:00.00000", "10:30:02.125", "23:59:60"
-- test time.partial rejects "", "24:10:10", "17:28:33.0r"

time.full = { time.partial time.offset }
-- the above tests should handle this
time.time = { time.partial time.offset }
-- the above tests should handle this

-- RFC2822 (Alternative patterns, less exact than RFC3339)
time.althour = time.d{2,2}
-- test time.althour accepts "00", "20", "85", "99"
-- test time.althour rejects "", "0", "9", "999"
time.altminute = time.d{2,2}
-- test time.altminute accepts "00", "38", "71", "99"
-- test time.altminute rejects "", "0", "7", "9999"
time.altsecond = time.d{2,2}
-- test time.altsecond accepts "01", "23", "45", "67"
-- test time.altsecond rejects "", "2", "5", "101"
time.altzone = { [+-] time.d{4,4} }
-- test time.altzone accepts "+0000", "-4321", "+9999", "-9870"
-- test time.altzone rejects "", "@0100", "-1", "+50", "1000"
time.alttimeofday = { time.althour ":" time.altminute { ":" time.altsecond }? }
-- test time.alttimeofday accepts "16:08:33", "01:55", "99:00:99", "00:00"
-- test time.alttimeofday rejects "", "2341", "10:50.22", "now"
time.alttime = time.alttimeofday time.altzone
-- the above tests should handle this
